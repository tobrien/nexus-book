<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.discursive.com/docbook/xml/4.5/docbookx.dtd">
<chapter id="repoman">
  <title>Repository Management</title>

  <section id="repoman-sect-repoman">
    <title>Repository Management</title>

    <para>Repository managers serve two purposes: they act as highly
    configurable proxies between your organization and the public Maven
    repositories and they also provide an organization with a deployment
    destination for its own generated artifacts. Just as Source Code
    Management (SCM) tools are designed to manage source artifacts, Repository
    Managers have been designed to manage and track external dependencies and
    artifacts generated by your build. They are an essential part of any
    enterprise or open-source software development effort, and they enable
    greater collaboration between developers and wider distribution of
    software.</para>

    <section>
      <title>Proxying Public Repositories</title>

      <para><indexterm>
          <primary>repository</primary>

          <secondary>proxy</secondary>
        </indexterm>Proxying and caching a remote public repository can speed
      up your builds by reducing redundant downloads over the public Internet.
      If a developer in your organization needs to download version 2.5 of the
      Spring Framework and you are using Nexus, the dependencies (and the
      dependency's dependencies) only need to be downloaded from the remote
      repository once. <indexterm>
          <primary>repository</primary>

          <secondary>proxy</secondary>

          <tertiary>benefits of</tertiary>
        </indexterm><indexterm>
          <primary>repository manager</primary>

          <secondary>benefits of</secondary>

          <tertiary>bandwidth savings</tertiary>
        </indexterm><indexterm>
          <primary>repository manager</primary>

          <secondary>benefits of</secondary>

          <tertiary>time savings</tertiary>
        </indexterm>With a high-speed connection to the Internet this might
      seem like a minor concern, but if you are constantly asking your
      developers to download hundreds of megabytes of third-party
      dependencies, the real cost savings are going to be the time it takes
      Maven to check for new versions of dependencies and to download
      dependencies over the public Internet.</para>

      <para>Proxying and serving Maven dependencies from a local repository
      cache can save you hundreds of HTTP requests over the public Internet,
      and, in very large multi-module projects, this can shave minutes from a
      build.</para>
    </section>

    <section>
      <title>Managing Releases and Snapshots</title>

      <para><indexterm>
          <primary>artifact</primary>

          <secondary>snapshot</secondary>
        </indexterm><indexterm>
          <primary>artifact</primary>

          <secondary>release</secondary>
        </indexterm>If your project is relying on a number of SNAPSHOT
      dependencies, Maven will need to regularly check for updated versions of
      these snapshots. Depending on the configuration of your remote
      repositories, Maven will check for SNAPSHOT updates periodically, or it
      might be checking for SNAPSHOT updates on every build. When Maven checks
      for a snapshot update it needs to interrogate the remote repository for
      the latest version of the SNAPSHOT dependency. Depending on your
      connection to the public Internet and the load on the Maven Central
      repository, a SNAPSHOT update can add seconds to your project's build
      for each SNAPSHOT dependency you rely upon.</para>

      <para>When you host a <indexterm>
          <primary>repository</primary>

          <secondary>local</secondary>
        </indexterm>local repository proxy with Nexus, you reduce the amount
      of time it takes for Maven to check for a newer version as your build
      interacts with a local repository cache. If you develop software with
      SNAPSHOT dependencies, using a local repository manager will save you a
      considerable amount of time, your 5-10 second SNAPSHOT update checks
      against the public central repository are going to execute in hundreds
      of milliseconds (or less) when they are executed against a local
      resource.</para>
    </section>

    <section id="repoman-sect-control-dep">
      <title>Getting Control of Dependencies</title>

      <para><indexterm>
          <primary>procurement</primary>
        </indexterm>In addition to the simple savings in time and bandwidth, a
      repository manager provides an organization with control over what is
      downloaded by Maven. You can include or exclude specific artifacts from
      the public repository, and having this level of control over what is
      downloaded from the Maven Central repository is a prerequisite for many
      organizations which have a need for strict standards for the quality and
      security of the dependencies used in an enterprise system.</para>

      <para><indexterm>
          <primary>procurement</primary>

          <secondary>standardization</secondary>
        </indexterm><indexterm>
          <primary>procurement</primary>

          <secondary>license management</secondary>
        </indexterm>If you want to standardize on a specific version of a
      dependency like Hibernate or Spring you can enforce this standardization
      by only providing access to a specific version of an artifact in Nexus.
      You might be concerned with making sure that every external dependency
      has a license compatible with your legal standards for adopting and
      integrating open source libraries. If you are producing an application
      which is distributed, you might want to make sure that no one
      inadvertently adds a dependency on a third-party library covered under a
      copy-left license like the GPL. All of this is possible with
      Nexus.</para>

      <para><indexterm>
          <primary>repository manager</primary>

          <secondary>benefits of</secondary>

          <tertiary>centralization</tertiary>
        </indexterm>Repository managers are a central point of access to
      external binary software artifacts and dependencies your system relies
      upon. Nexus provides a level of control that is essential when you are
      trying to track and manage the libraries and frameworks your software
      depends upon.</para>
    </section>

    <section>
      <title>A Nexus for Collaboration</title>

      <para><indexterm>
          <primary>repository manager</primary>

          <secondary>benefits of</secondary>

          <tertiary>collaboration</tertiary>
        </indexterm><indexterm>
          <primary>artifact</primary>

          <secondary>internal</secondary>
        </indexterm>Aside from the benefits of mediating access to remote
      repositories, a repository manager also provides an important platform
      for collaborative software development. Unless you expect every member
      of your organization to download and build every single internal project
      from source, you will want to provide a mechanism for developers and
      departments to share binary artifacts (both SNAPSHOTs and releases) for
      internal software projects. Internal groups often consume the APIs and
      systems which are generated by other internal groups, when you adopt
      Nexus as a deployment platform for internal artifacts, you can easily
      share components and libraries between groups of developers.</para>

      <para>Nexus provides you with a deployment target for your software
      components. Once you install Nexus, you can start using Maven to deploy
      snapshots and releases to internal repositories which can then be
      combined with other repositories in repository groups. Over time, this
      central deployment point for internal projects becomes the fabric for
      collaboration between different development teams and operations. Nexus
      is the secret ingredient that allows an organization to scale its
      development effort without sacrificing agility.</para>
    </section>
  </section>

  <section>
    <title>What is a Repository?</title>

    <para><indexterm>
        <primary>repository</primary>

        <secondary>definition</secondary>
      </indexterm>Maven developers are familiar with the concept of a
    repository: a collection of <indexterm>
        <primary>artifact</primary>

        <secondary>binary</secondary>
      </indexterm><indexterm>
        <primary>artifact</primary>

        <secondary>metadata</secondary>
      </indexterm>binary software artifacts and metadata stored in a defined
    directory structure which is used by clients such <indexterm>
        <primary>Apache Maven</primary>
      </indexterm><indexterm>
        <primary>Maven</primary>

        <see>Apache Maven</see>
      </indexterm> Apache Maven, <indexterm>
        <primary>Apache Ant</primary>
      </indexterm><indexterm>
        <primary>Ant</primary>

        <see>Apache Ant</see>
      </indexterm>Apache Ant with Maven tasks, or <indexterm>
        <primary>Apache Ivy</primary>
      </indexterm><indexterm>
        <primary>Ivy</primary>

        <see>Apache Ivy</see>
      </indexterm>Apache Ivy to retrieve binaries during a build process. In
    the case of the Maven repository, the primary type of binary artifact is a
    JAR file containing Java bytecode, but there is no limit to what type of
    artifact can be stored in a Maven repository. For example, one could just
    as easily deploy documentation archives, source archives, Flash libraries
    and applications, or Ruby libraries to a Maven repository. A Maven
    repository provides a platform for the storage, retrieval, and management
    of binary software artifacts and metadata.</para>

    <para>In Maven, every software artifact is described by an XML document
    called a <indexterm>
        <primary>Project Object Model</primary>
      </indexterm><indexterm>
        <primary>POM</primary>

        <see>Project Object Model</see>
      </indexterm>Project Object Model (POM). This POM contains information
    that describes a project and lists a project’s dependencies - the binary
    software artifacts which a given component depends upon for successful
    compilation or execution. <indexterm>
        <primary>dependency management</primary>
      </indexterm><indexterm>
        <primary>Apache Maven</primary>

        <secondary>dependency management</secondary>
      </indexterm>When Maven downloads a dependency from a repository, it also
    downloads that dependency’s POM. Given a dependency’s POM, Maven can then
    download any other libraries which are required by that dependency. The
    ability to automatically calculate a project’s dependencies and transitive
    dependencies is made possible by the standard and structure set by the
    Maven repository.</para>

    <para>Maven and other tools such as Ivy which interact with a repository
    to search for binary software artifacts, model the projects they manage,
    and retrieve software artifacts on-demand from a repository. When you
    download and install Maven without any customization, Maven will retrieve
    artifacts from a Maven Central repository which serves millions of Maven
    users every single day. While you can configure Maven to retrieve binary
    software artifacts from a collection of mirrors, the best-practice is to
    install Nexus and use it to proxy and cache the contents of Central on
    your own network. <indexterm>
        <primary>repository</primary>

        <secondary>public</secondary>
      </indexterm><indexterm>
        <primary>public repositories</primary>
      </indexterm>In addition to Central, there are a number of major
    organizations such as Redhat, Sun Microsystems, and Codehaus which
    maintain separate repositories.</para>

    <para>While this might seem like a simple, obvious mechanism for
    distributing artifacts, the Java platform existed for several years before
    the Maven project created a formal attempt at the first repository for
    Java artifacts. Until the advent of the <indexterm>
        <primary>public repositories</primary>

        <secondary>Maven Central Repository</secondary>
      </indexterm>Maven repository in 2002, a project’s dependencies were
    gathered in a manual, ad-hoc process and were often distributed with a
    project's source code. As applications grew more and more complex, and as
    software teams developed a need for more complex dependency management
    capabilities for larger enterprise applications, Maven’s ability to
    automatically retrieve dependencies and model dependencies between
    components became an essential part of software development.</para>

    <section>
      <title>Release and Snapshot Repositories</title>

      <para><indexterm>
          <primary>repository</primary>

          <secondary>policy</secondary>

          <tertiary>release</tertiary>
        </indexterm><indexterm>
          <primary>repository</primary>

          <secondary>policy</secondary>

          <tertiary>snapshot</tertiary>
        </indexterm>A repository stores two types of artifacts: releases and
      snapshots. Release repositories are for stable, static release artifacts
      and snapshot repositories are frequently updated repositories that store
      binary software artifacts from projects under constant
      development.</para>

      <para>While it is possible to create a repository which serves both
      release and snapshot artifacts, repositories are usually segmented into
      release or snapshot repositories serving different consumers and
      maintaining different standards and procedures for deploying artifacts.
      Much like the difference between a production network and a staging
      network, a release repository is considered a production network and a
      snapshot repository is more like a development or a testing network.
      While there is a higher level of procedure and ceremony associated with
      deploying to a release repository, snapshot artifacts can be deployed
      and changed frequently without regard for stability and repeatability
      concerns.</para>

      <para>The two types of artifacts managed by a repository manager
      are:</para>

      <variablelist>
        <varlistentry>
          <term><indexterm>
              <primary>artifact</primary>

              <secondary>release</secondary>
            </indexterm>Release Artifacts</term>

          <listitem>
            <para>A release artifact is an artifact which was created by a
            specific, versioned release. For example, consider the 1.2.0
            release of the commons-lang library stored in the Maven Central
            repository. This release artifact, commons-lang-1.2.0.jar, and the
            associated POM, commons-lang-1.2.0.pom, are static objects which
            will never change in the Maven Central repository. Released
            artifacts are considered to be solid, stable, and perpetual in
            order to guarantee that builds which depend upon them are
            repeatable over time. The released JAR artifact is associated with
            a PGP signature, an MD5 and SHA checksum which can be used to
            verify both the authenticity and integrity of the binary software
            artifact.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><indexterm>
              <primary>artifact</primary>

              <secondary>snapshot</secondary>
            </indexterm>Snapshot Artifacts</term>

          <listitem>
            <para>Snapshot artifacts are artifacts generated during the
            development of a software project. A Snapshot artifact has both a
            version number such as “1.3.0” or “1.3” and a timestamp in its
            name. For example, a snapshot artifact for commons-lang 1.3.0
            might have the name commons-lang-1.3.0-20090314.182342-1.jar the
            associated POM, MD5 and SHA hashes would also have a similar name.
            To facilitate collaboration during the development of software
            components, Maven and other clients which know how to consume
            snapshot artifacts from a repository also know how to interrogate
            the metadata associated with a Snapshot artifact to retrieve the
            latest version of a Snapshot dependency from a repository.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>A project under active development produces SNAPSHOT artifacts
      that change over time. A release is comprised of artifacts which will
      remain unchanged over time.</para>
    </section>

    <section>
      <title>Repository Coordinates</title>

      <para><indexterm>
          <primary>repository</primary>

          <secondary>coordinates</secondary>
        </indexterm><indexterm>
          <primary>artifact</primary>

          <secondary>coordinates</secondary>
        </indexterm><indexterm>
          <primary>GAV Coordinates</primary>

          <see>artifact, coordinates</see>
        </indexterm>Repositories and tools like Maven know about a set of
      coordinates including the following components: groupId, artifactId,
      version, and packaging. This set of coordinates is often referred to as
      a GAV coordinate which is short for “Group, Artifact, Version
      coordinate”. The GAV coordinate standard is the foundation for Maven’s
      ability to manage dependencies. Four elements of this coordinate system
      are described below:</para>

      <variablelist>
        <varlistentry>
          <term><indexterm>
              <primary>coordinate</primary>

              <secondary>groupId</secondary>
            </indexterm>Group Identifier (groupId)</term>

          <listitem>
            <para>A group identifier groups a set of artifacts into a logical
            group. Groups are often designed to reflect the organization under
            which a particular software component is being produced. For
            example, software components being produced by the Maven project
            at the Apache Software Foundation are available under the groupId
            org.apache.maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><indexterm>
              <primary>coordinate</primary>

              <secondary>artifactId</secondary>
            </indexterm>Artifact Identifier (artifactId)</term>

          <listitem>
            <para>An artifact is an identifier for a software component. An
            artifact can represent an application or a library; for example,
            if you were creating a simple web application your project might
            have the artifactId “simple-webapp”, and if you were creating a
            simple library, your artifact might be “simple-library”. The
            combination of groupId and artifactId must be unique for a
            project.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><indexterm>
              <primary>coordinate</primary>

              <secondary>version</secondary>
            </indexterm>Version (version)</term>

          <listitem>
            <para>The version of a project follows the established convention
            of Major, Minor, and Point release versions. For example, if your
            simple-library artifact has a Major release version of 1, a minor
            release version of 2, and point release version of 3, your version
            would be 1.2.3. Versions can also have alphanumeric qualifiers
            which are often used to denote release status. An example of such
            a qualifier would be a version like “1.2.3-BETA” where BETA
            signals a stage of testing meaningful to consumers of a software
            component.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><indexterm>
              <primary>coordinate</primary>

              <secondary>packaging</secondary>
            </indexterm>Packaging (packaging)</term>

          <listitem>
            <para>Maven was initially created to handle JAR files, but a Maven
            repository is completely agnostic about the type of artifact it is
            managing. Packaging can be anything that describes any binary
            software format including ZIP, SWC, SWF, NAR, WAR, EAR,
            SAR.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="repoman-sect-address-resources">
      <title>Addressing Resources in a Repository</title>

      <para><indexterm>
          <primary>repository</primary>

          <secondary>layout</secondary>
        </indexterm><indexterm>
          <primary>coordinate</primary>

          <secondary>URL</secondary>
        </indexterm>Tools designed to interact Maven repositories translate
      artifact coordinates into a URL which corresponds to a location in a
      Maven repository. If a tool such as Maven is looking for version 1.2.0
      of the commons-lang JAR in the group org.apache.commons, this request is
      translated into:</para>

      <screen>&lt;repoURL&gt;/org/apache/commons/commons-lang/1.2.0/commons-lang-1.2.0.jar</screen>

      <para>Maven would also download the corresponding POM for commons-lang
      1.2.0 from:</para>

      <screen>&lt;repoURL&gt;/org/apache/commons/commons-lang/1.2.0/commons-lang-1.2.0.pom</screen>

      <para>This POM may contain references to other dependencies which would
      then be retrieved from the same repository using the same URL
      patterns.</para>
    </section>

    <section id="repoman-sect-central">
      <title>The Maven Central Repository</title>

      <para><indexterm>
          <primary>public repositories</primary>

          <secondary>Maven Central</secondary>
        </indexterm><indexterm>
          <primary>Central</primary>

          <see>public repositories, Maven Central</see>
        </indexterm>The most useful Maven repository is the Maven Central
      Repository. The Maven Central repository contains almost 90,000 software
      artifacts occupying around 70 GB of disk space. You can look at Central
      as an example of how Maven repositories operate and how they are
      assembled. Here are some of the properties of release repositories such
      as the Maven Central repository:</para>

      <variablelist>
        <varlistentry>
          <term>Artifact Metadata</term>

          <listitem>
            <para>All software artifacts added to Central require proper
            metadata including a Project Object Model (POM) for each artifact
            which describes the artifact itself, and any dependencies that
            software artifact might have.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Release Stability</term>

          <listitem>
            <para>Once published to the Maven Central repository, an artifact
            and the metadata describing that artifact never change. This
            property of release repositories guarantees that projects which
            depend on releases will be repeatable and stable over time. While
            new software artifacts are being published to central every day,
            once an artifact is assigned a release number on Central, there is
            a strict policy against modifying the contents of a software
            artifact after a release.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Repository Mirrors</term>

          <listitem>
            <para>Central is a public resource, and it is currently used by
            the millions of developers who have adopted Maven and the tools
            that understand how to interact with the Maven repository
            structure. There are a series of mirrors for the Central
            repository which are constantly synchronized with Central. Users
            are encouraged to query central for project metadata and
            cryptographic hashes and they are encouraged to retrieve the
            actual software artifacts from one of Central's many mirrors.
            Tools like Nexus are designed to retrieve metadata from Central
            and artifact binaries from mirrors.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Artifact Security</term>

          <listitem>
            <para>The Maven Central repository contains <indexterm>
                <primary>cryptographic hash</primary>
              </indexterm>cryptographic hashes and PGP signatures which can be
            used to verify the authenticity and integrity of software
            artifacts served from Central or one of the many mirrors of
            Central.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section id="repoman-sect-repodef">
    <title>What is a Repository Manager</title>

    <para><indexterm>
        <primary>repository manager</primary>

        <secondary>benefits of</secondary>
      </indexterm>If you use Maven, you are using a repository to retrieve
    artifacts and Maven plugins. In fact, Maven used a Maven repository to
    retrieve core plugins that implement the bulk of the features used in your
    builds. Once you start to rely on repositories, you realize how easy it is
    to add a dependency on an open source software library available in the
    Maven Central repository, and you might start to wonder how you can
    provide a similar level of convenience for your own developers. When you
    install a repository manager, you are bringing the power of a repository
    like Central into your organization, you can use it to proxy Central, and
    host your own repositories for internal and external use. In this section,
    we discuss the core functionality which defines what a repository manager
    does.</para>

    <para>Put simply, a repository manager provides two core features:</para>

    <itemizedlist>
      <listitem>
        <para>The ability to proxy a remote repository and cache artifacts
        saving both bandwidth and time required to retrieve a software
        artifact from a remote repository, and</para>
      </listitem>

      <listitem>
        <para>The ability the host a repository providing an organization with
        a deployment target for software artifacts.</para>
      </listitem>
    </itemizedlist>

    <para>In addition to these two core features, a repository manager also
    allows you to manage binary software artifacts through the software
    development lifecycle, search and catalog software artifacts, audit
    development and release transactions, and integrate with external security
    systems such as LDAP. The following sections define the feature sets of
    Nexus Open Source and Nexus Professional.</para>

    <section id="sect-repoman-features-os">
      <title>Core Capabilities of a Repository Manager</title>

      <para><indexterm>
          <primary>Nexus Open Source</primary>

          <secondary>features</secondary>
        </indexterm>The base-line features of a repository manager are a
      description of the core capabilities of Nexus Open Source. Nexus Open
      Source provides for the:</para>

      <variablelist>
        <varlistentry>
          <term>Management of Software Artifacts</term>

          <listitem>
            <para>A repository manager is able to manage packaged binary
            software artifacts. In Java development, this would include JARs
            containing bytecode, source, or javadoc. In other environments,
            such as Flex, this would include any SWCs or SWFs generated by a
            Flex build.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Management of Software Metadata</term>

          <listitem>
            <para>A repository manager should have some knowledge of the
            metadata which describes artifacts. In a Maven repository this
            would include project coordinates (groupId, artifactId, version,
            classifier) and information about a given artifact’s
            releases.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Proxying of External Repositories</term>

          <listitem>
            <para>Proxying an external repository yields more stable builds as
            the artifacts used in a build can be served to clients from the
            repository manager’s cache even if the external repository becomes
            unavailable. Proxying also saves bandwidth and time as checking
            for the presence of an artifact on a local network is often orders
            of magnitude faster than querying a heavily loaded public
            repository</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Deployment to Hosted Repositories</term>

          <listitem>
            <para>Organizations which deploy internal snapshots and releases
            to hosted repositories have an easier time distributing software
            artifacts across different teams and departments. When a
            department or development group deploys artifacts to a hosted
            repository, other departments and development groups can develop
            systems in parallel, relying upon dependencies served from both
            release and snapshot repositories.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Searching an Index of Artifacts</term>

          <listitem>
            <para>When you collect software artifacts and metadata in a
            repository manager, you gain the ability to create indexes and
            allow users and systems to search for artifacts. With the Nexus
            index, an IDE such as Eclipse has almost instantaneous access to
            the contents of all proxy repositories (including the Central
            repository) as well as access to your own internal and 3rd party
            artifacts. While the Central repository transformed the way that
            software is distributed, the Nexus index format brings the power
            of search to massive libraries of software artifacts.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Infrastructure for Artifact Management</term>

          <listitem>
            <para>A repository manager should also provide the appropriate
            infrastructure for managing software artifacts and a solid API for
            extension. In Nexus, Sonatype has provided a plugin API which
            allows developers to customize both the behavior, appearance, and
            functionality of the tool.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="sect-repoman-features-pro">
      <title>Additional Features of a Repository Manager</title>

      <para><indexterm>
          <primary>Nexus Professional</primary>

          <secondary>features</secondary>
        </indexterm>Once you adopt the core features of a repository manager,
      you start to view a repository manager as a tool which enables more
      efficient collaboration between development groups. Nexus Professional
      builds upon the foundations of a repository manager and adds
      capabilities such as Procurement and Staging.</para>

      <variablelist>
        <varlistentry>
          <term>Managing Project Dependencies</term>

          <listitem>
            <para>Many organizations require some level of oversight over the
            open source libraries and external artifacts that are let into an
            organization’s development cycle. An organization could have
            specific legal or regulatory constraints which requires every
            dependency to be subjected to a rigorous legal or security audit
            before it is integrated into a development environment. Another
            organization might have an architecture group which needs to make
            sure that a large set of developers only has access to a
            well-defined list of dependencies or specific versions of
            dependencies. Using the Procurement features of Nexus
            Professional, managers and architecture groups have the ability to
            allow and deny specific artifacts from external
            repositories.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Managing a Software Release</term>

          <listitem>
            <para>Nexus Professional adds some essential workflow to the
            process of staging software to a release repository. Using Nexus
            Professional, developers can deploy to a staging directory which
            can trigger a message to a Release Manager or to someone
            responsible for QA. Quality assurance (or a development manager)
            can then test and certify a release having the option to promote a
            release to the release repository or to discard a release if it
            didn’t meet release standards. Nexus Professional’s staging
            features allow managers to specify which personnel are allowed to
            certify that a release can be promoted to a release repository
            giving an organization more control over what software artifacts
            are released and who can release them.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Integration with LDAP</term>

          <listitem>
            <para>Nexus integrates with an LDAP directory, allowing an
            organization to connect Nexus to an existing directory of users
            and groups. Nexus authenticates users against an LDAP server and
            provides several mechanisms for mapping existing LDAP groups to
            Nexus roles.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Advanced Security</term>

          <listitem>
            <para>Using Nexus Professional, an organization can define a
            master User Password Encryption Key. Each user will be given a
            separate Maven settings file with an encrypted password using the
            Maven Nexus plugin. When users interact with Nexus, Nexus uses the
            User Password Encryption Key to decrypt a user’s Nexus credentials
            avoiding the need to send an easily compromised plain-text
            password over the network.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Settings Templates</term>

          <listitem>
            <para>Nexus Professional allows you to define Maven settings
            templates for developers. Developers can then automatically
            receive updates to Maven settings (~/.m2/settings.xml) using the
            Maven Nexus plugin. The ability to define Maven settings templates
            and to distribute customized Maven settings files to developers
            makes it easy for an organization to change global profiles or
            repository configuration without relying on developers to manually
            install a new settings file in a development environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Support for Multiple Repository Formats</term>

          <listitem>
            <para>Nexus Professional supports the p2 and the OSGi Bundle
            repository format used by the new Eclipse provisioning platform
            and OSGi developers. You can use the p2 plugin to consolidate,
            provision, and control the plugins that are being used in an
            Eclipse IDE. Using Nexus procurement, repository groups, and proxy
            repositories to consolidate multiple plugin repositories, an
            organization can use Nexus Professional to standardize the
            configuration of Eclipse IDE development environments.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section id="sect-repoman-reasons">
    <title>Reasons to Use a Repository Manager</title>

    <para><indexterm>
        <primary>repository manager</primary>

        <secondary>reasons to use</secondary>
      </indexterm>Here are a few reasons why using a repository manager is an
    imperative. While most people wouldn't even think of developing software
    without the use of a source code control system like Subversion or
    Perforce, the concept of using a repository manager is still something
    that needs development. There are many who use Maven for years without
    realizing the benefits of using a repository manager. This section was
    written as an attempt to capture some of the benefits of using a
    repository manager.</para>

    <section>
      <title>Speed Up Your Builds</title>

      <para>When you run your multi-module project in Maven, how do you think
      Maven knows if it needs to update plugins or snapshot dependencies? It
      has to make a request for each artifact it needs to test. Even if
      nothing has changed, if your project depends on a few SNAPSHOTs or if
      you don’t specify plugin version, Maven might have to make tens to
      hundreds of requests to a remote repository. All of these requests over
      the public Internet add up to real, wasted, time. I’ve seen complex
      builds cut build time by 75% after installing a local instance of Nexus.
      You are wasting time better spent coding waiting for your build to
      needlessly interrogate a remote Maven repository.</para>
    </section>

    <section>
      <title>Save Bandwidth</title>

      <para>The larger the organization, the more critical bandwidth savings
      can be. If you have thousands of developers regularly wasting good
      bandwidth to download the same files over and over again, using a
      repository manager to keep a local cache is going to save you a good
      deal of bandwidth. Even for smaller organizations with limited budgets
      for connectivity and IT operations, having to deal with a set of
      developers maxing out your connection to the Internet to download the
      same things over and over again seems backwards.</para>
    </section>

    <section id="repoman-sect-burden-central">
      <title>Ease the Burden on Central</title>

      <para>Running the Maven Central repository is no short order. It ain’t
      cheap to serve the millions of requests and Terabytes of data required
      to satisfy the global demand for software artifacts from the Maven
      Central repository. Something as simple as installing a repository
      manager at every organization that uses Maven would likely cut the
      bandwidth requirements for Central by at least half. If you have more
      than a couple developers using Maven, install a repository manager for
      the sake of keeping Central available and in business.</para>
    </section>

    <section>
      <title>Gain Predictability and Scalability</title>

      <para>How often in the past few years has your business come to a
      crashing halt because of an outage? Depending on Central for your day to
      day operations also means that you depend on having Internet
      connectivity (and on the fact the Central will remain available 24/7).
      While Sonatype is confident in its ability to keep Central running 24/7,
      you should take some steps of your own to make sure that your
      development team isn’t going to be surprised by some network outage on
      either end. If you have a local repository manager, like Nexus, you can
      be sure that your builds will continue to work even if you lose
      connectivity.</para>
    </section>

    <section>
      <title>Control and Audit Dependencies and Releases</title>

      <para>So, you’ve moved over to Maven (or maybe Ivy, Ivy reads the same
      repository), and you now have a whole room full of developers who feel
      empowered to add or remove dependencies and experiment with new
      frameworks. We’ve all seen this. We’ve all worked in places with a
      developer who might be more interested in experimenting than in working.
      It is unfortunate to say so, but there are often times when an
      architect, or an architecture group needs to establish some baseline
      standards which are going to be used in an organization. Nexus provides
      this level of control. If you need more oversight over the artifacts
      that are making it into your organization, take a look at Nexus. Without
      a repository manager, you are going to have little control over what
      dependencies are going to be used by your development team.</para>
    </section>

    <section id="repoman-sect-deploy-3rd">
      <title>Deploy 3rd Party Artifacts</title>

      <para>How do you deal with that one-off JAR from a vendor that is not
      open source, and not available on the Maven Central repository? You need
      to deploy these artifacts to a repository and configure your Maven
      instance to read from that repository. Instead of handcrafting some
      POMs, download Nexus and take the two or three minutes it is going to
      take to get your hands on a tool that can create such a repository from
      3rd-party artifacts. Nexus provides an intuitive upload form that you
      can use to upload any random free-floating JAR that finds its way into
      your project’s dependencies.</para>
    </section>

    <section>
      <title>Collaborate with Internal Repositories</title>

      <para>Many organizations require every developer to checkout and build
      the entire system from source simply because they have no good way of
      sharing internal JARs from a build. You can solve a problem like this by
      splitting projects up and using Nexus as an internal repository to host
      internal dependencies.</para>

      <para>For example, consider a company that has 30 developers split into
      three groups of 10, each group focused on a different part of the
      system. Without an easy way to share internal dependencies, a group like
      this is forced either to create an ad hoc filesystem-based repository or
      to build the system in its entirety so that dependencies are installed
      in every developer’s local repository.</para>

      <para>The alternative is to separate the projects into different modules
      that all have dependencies on artifacts hosted by an internal Nexus
      repository. Once you’ve done this, groups can collaborate by exchanging
      compiled snapshot and release artifacts via Nexus. In other words, you
      don’t need to ask every developer to checkout a massive multi-module
      project that includes the entire organization’s code. Each group within
      the organization can deploy snapshots and artifacts to a local Nexus
      instance, and each group can maintain a project structure which includes
      only the projects it is responsible for.</para>
    </section>

    <section>
      <title>Distribute with Public Repositories</title>

      <para><indexterm>
          <primary>repository manager</primary>

          <secondary>distribution via</secondary>
        </indexterm>If you are an open source project, or if you release
      software to the public, Nexus can be the tool you use to serve artifacts
      to external users. Think about it this way… When was the last time you
      cut a release for your software project? Assuming it wasn’t deployed to
      a Maven repository, you likely had to write some scripts to package the
      contents of the release, maybe someone special had to sign the release
      with a super-secret cryptographic key. Then, you had to upload it to
      some web server, and then make sure that the pages that describe the
      upload were themselves updated. Lots of needless complexity…</para>

      <para>If you were using something like Nexus, which can be configured to
      expose a hosted repository to the outside world, you could use the
      packaging and assembly capabilities of Maven and the structure of the
      Maven repository to make a release that is more easily consumed. And,
      this isn’t just for JAR files and Java web applications; Maven
      repositories can host any kind of artifact. Nexus, and Maven
      repositories in general, define a known structure for releases. If you
      are writing some Java library, publishing it to your own Nexus instance
      serving a public repository will make it easier for people to start
      using your code right away.</para>
    </section>
  </section>

  <section>
    <title>Adopting a Repository Manager</title>

    <para><indexterm>
        <primary>repository manager</primary>

        <secondary>adoption of</secondary>
      </indexterm>This section talks about the stages of moving to a
    repository manager. Adopting a repository manager is not an all or nothing
    proposition, and there are various levels (or stages) of adoption that can
    be distinguished when approaching repository management. On one end of the
    adoption spectrum is the organization that installs a repository manager
    just to control and consolidate access to a set of remote repositories. On
    the other end of the spectrum is the organization which has integrated the
    repository manager into an efficient software development lifecycle, using
    it to facilitate decision points in the lifecycle, encouraging more
    efficient collaboration throughout the enterprise, and keeping detailed
    records to increase visibility into the software development
    process.</para>

    <section id="repoman-sect-stage0">
      <title>Stage Zero: Before Using a Repository Manager</title>

      <para>While this isn’t a stage of adoption, Stage Zero is a description
      of the way software builds work in the absence of a repository manager.
      When a developer decides that a he needs a particular open source
      software component, he will download it from the component’s website,
      read the documentation, and find the additional software that his
      components rely on (referred to as “dependencies”). Once he has manually
      assembled a collection of dependencies from various open source project
      web sites and proprietary vendors, he will place all these components
      somewhere on the network so that he, his team members, the build script,
      the QA team, and the production support team can find it. At any time,
      other developers may bring in other components, sometimes with
      overlapping dependencies, placing them in different network locations.
      The instructions to bring all of these ad-hoc, developer-managed
      components libraries together in a software build process can become
      very complicated and hard to maintain.</para>

      <para>Maven was introduced to improve this build process by introducing
      the concept of structured repositories from which the build scripts can
      retrieve the software components. In Maven language, these software
      components or dependencies are referred to as “artifacts”, a term which
      can refer to any generic software artifact including components,
      libraries, frameworks, containers, etc. Maven can identify artifacts in
      repositories, understand their dependencies, retrieve all that are
      needed for a successful build, and deploy its output back to
      repositories when done.</para>

      <para>Developers using Maven without a repository manager find most of
      their software artifacts and dependencies in Maven Central. If they
      happen to use another remote repository or if they need to add a custom
      artifact, the solution, in Stage Zero, is to manually manipulate the
      files in a local repository and share this local repository with
      multiple developers. While this approach may yield a working build for a
      small team, managing a shared local repository doesn’t allow an
      organization to scale a development effort. There is no inherent control
      over who can set up a local repository, who can add to them or change or
      delete from them, nor are there tools to protect the integrity of these
      repositories.</para>

      <para>That is, until Repository Managers were introduced.</para>
    </section>

    <section id="repoman-sect-stage1">
      <title>Stage One: Proxying Remote Repositories</title>

      <para>This is the easiest stage to understand both in terms of benefits
      to an organization and action required to complete this stage. All you
      need to do to start proxying a remote repository is to deploy Nexus and
      start the server with the default configuration. Configure your Maven
      clients to read from the Nexus public repository group, and Nexus will
      automatically retrieve artifacts from remote repositories, such as Maven
      Central, caching them locally.</para>

      <para>Without a repository manager, your organization might have
      hundreds of developers independently downloading the same artifacts from
      public, remote repositories. With a repository manager, these artifacts
      can be downloaded once and stored locally. After Stage One, your builds
      run considerably faster than they did when you relied upon the Maven
      Central repository.</para>

      <para>Once you’ve installed Nexus and you’ve configured all of your
      organization’s clients to use it as a single point of access to remote
      repositories, you begin to realize that it now provides you with a
      central configuration point for the artifacts used throughout your
      organization. Once you’ve started to proxy, you can start to think about
      using Nexus as a tool to control policy and what dependencies are
      allowed to be used in your organization. Nexus Professional provides a
      procurement plugin which allows for fine-grained control over which
      artifacts can be accessed from a remote repository. This procurement
      feature is described in more detail in the section which deals with
      Lifecycle Integration.</para>
    </section>

    <section id="repoman-sect-stage2">
      <title>Stage Two: Hosting a Repository Manager</title>

      <para>Once you have started to proxy remote repositories and you are
      using Nexus as a single, consolidated access point for remote
      repositories, you can start to deploy your own artifacts to Nexus hosted
      repositories. Most people approach repository management to find a
      solution for proxying remote repositories, and while proxying is the
      most obvious and immediate benefit of installing a repository manager,
      hosting internally generated artifacts tends to be the stage that has
      the most impact on collaboration within an organization.</para>

      <para>To understand the benefits of hosting an internal repository, you
      have to understand the concept of managing binary software artifacts.
      Software development teams are very familiar with the idea of a source
      code repository or a source code management tool. Versioning control
      systems such as Subversion, Clearcase, Git, and CVS provide solid tools
      for managing the various source artifacts that comprise a complex
      enterprise application, and developers are comfortable checking source
      out from source control to build enterprise applications. However, past
      a certain point in the software development lifecycle, source artifacts
      are no longer relevant. A QA department trying to test an application or
      an Operations team attempting to deploy an application to a production
      network no longer needs access to the source artifacts. QA and
      Operations are more interested in the compiled end-product of the
      software development lifecycle: the binary software artifacts. A
      repository manager allows you to version, store, search, archive, and
      release binary software artifacts derived from the source artifacts
      stored in a source control system. A repository manager allows you to
      apply the same systematic operations on binary software artifacts which
      you currently apply to your source code.</para>

      <para>When your build system starts to deploy artifacts to an internal
      repository, it changes the way that developers and development groups
      can interact with one another in an enterprise. Developers in one
      development group can code and release a stable version of an internal
      library, deploy this library to an internal Nexus release repository,
      and so share this binary artifact with another group or department.
      Without a repository manager managing internal artifacts, you have
      ad-hoc solutions and the organizational equivalent of "duct tape". How
      does the infrastructure group send a new library to the applications
      group without Nexus? Someone copies a file to a shared directory, and
      sends an email to the team lead. Organizations without repository
      managers are full of these ad-hoc processes that get in the way of
      efficient development and deployment.</para>

      <para>With a repository manager, every developer and every development
      group within the enterprise understands and interacts with a common
      collaborative structure: the repository manager. Do you need to interact
      with the Commerce team’s new API? Just add a dependency to your project
      and Maven will retrieve the library from Nexus automatically.</para>

      <para>One of the other direct benefits of deploying your own artifacts
      to a repository such as Nexus is the ability to quickly search the
      metadata and contents of those artifacts both via a web UI and through
      IDE integration tools such as m2eclipse. When you start to deploy
      internal artifacts you can synchronize all development groups to a
      common versioning and naming standard, and you can use the highly
      configurable authentication and role-based access controls to control
      which developers and which development groups can deploy artifacts to
      specific repositories or paths within a repository.</para>
    </section>

    <section id="repoman-sect-stage3">
      <title>Stage Three: Continuous Collaboration</title>

      <para><indexterm>
          <primary>continuous collaboration</primary>
        </indexterm>Developing this collaborative model further, if your
      application is being continuously built and deployed using a tool like
      Hudson, a developer can checkout a specific module from a large
      multi-module build and not have to constantly deal with the entire
      source tree at any given time. This allows a software development effort
      to scale efficiently. If every developer working on a complex enterprise
      application needs to checkout the entire source tree every time he or
      she needs to make a simple change to a small component, you are quickly
      going to find that building the entire application becomes a burdensome
      bottleneck to progress. The larger your enterprise grows, the more
      complex your application becomes, the larger the collective burden of
      wasted time and missed opportunities. A slow enterprise build prevents
      the quick turnaround or quick feedback loop that helps your developers
      maintain focus during a development cycle.</para>

      <para>Once you are building with Maven, sharing binary artifacts with
      Nexus, continuously testing and deploying with Hudson, and generating
      reports and metrics with tools like Sonar, your entire organization
      gains a collaborative "central nervous system" that enables a more agile
      approach to software development.</para>
    </section>

    <section id="repoman-sect-stage4">
      <title>Stage Four: Lifecycle Integration</title>

      <para><indexterm>
          <primary>software development lifecycle (SLDC)</primary>
        </indexterm><indexterm>
          <primary>repository management</primary>

          <secondary>withing software lifecycle</secondary>
        </indexterm>Once you’ve configured a repository manager to proxy
      remote repositories and you are using a repository manager as an
      integration point between developers and departments, you start to think
      about the various ways your repository manager can be used to support
      the decisions that go into software development. You can start using the
      repository manager to stage releases and supporting the workflow
      associated with a managed release, and you can use the procurement
      features of a tool like Nexus Professional to give management more
      visibility into the origins, characteristics and open source licenses of
      the artifacts used during the creation of an enterprise
      application.</para>

      <para>Nexus Professional enables organizations to integrate the
      management of software artifacts tightly with the software development
      lifecycle: Developer Onboarding, Provisioning, Compliance, Procurement,
      Enterprise Security, Staging and other capabilities that support the
      workflow that surrounds a modern software development effort.</para>

      <variablelist>
        <varlistentry>
          <term>Developer Onboarding</term>

          <listitem>
            <para><indexterm>
                <primary>developer onboarding</primary>
              </indexterm>Using Nexus Professional’s support for Eclipse
            plugin repositories, Nexus can be used to dramatically reduce the
            time required to provision a new Eclipse environment for a new
            developer. Using Nexus’ p2 repository support, a developer’s IDE
            can be quickly configured from a set of Eclipse plugins managed
            and procured via Nexus Professional and delivered directly to the
            developer’s desktop.</para>

            <para>Using Nexus Professional’s Maven Settings management feature
            and integrated security features you can configure a developer’s
            Maven settings by running a single, convenient Maven goal and
            downloading customized settings for a particular developer. When
            you use Maven and Nexus Professional together, developers can get
            up and running quickly, collaborating on projects that share
            common conventions without having to manually install dependencies
            in local repositories.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Provisioning</term>

          <listitem>
            <para><indexterm>
                <primary>provisioning</primary>
              </indexterm>Using Nexus as an integration point between
            Engineering and Operations means that Engineering can be
            responsible for delivering solid, tested artifacts to Quality
            Assurance and Operations via a standard repository format. Often
            development teams are roped into the production deployment story
            and become responsible for building entire production environments
            within a build system. This conflates software engineering with
            system administration and blurs the line between Engineering and
            Operations. If you use Nexus as a end-point for releases from
            Engineering, Operations can then retrieve, assemble, and configure
            an application from tested components in the Nexus
            repository.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Compliance</term>

          <listitem>
            <para><indexterm>
                <primary>compliance</primary>
              </indexterm><indexterm>
                <primary>procurement</primary>
              </indexterm><indexterm>
                <primary>staging</primary>
              </indexterm>Procurement, staging, and audit logs are all
            features which increase the visibility into who and what is
            involved with your software development effort. Using Nexus
            Professional, Engineering can create the reports and documents
            which can be used to facilitate discussions about oversight.
            Organizations subject to various regulations often need to produce
            a list of components involved in a software release. Legal
            departments often require a list of open source licenses being
            used in a particular software component, and managers often lack
            critical visibility into the software development process.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Procurement</term>

          <listitem>
            <para><indexterm>
                <primary>procurement</primary>
              </indexterm>The ease with which today’s developer can add a
            dependency on a new open source library and download this library
            from a Central repository has a downside. Organizations large and
            small are constantly wondering what open source libraries are
            being used in applications, and whether these libraries have
            acceptable open source licenses for distribution. The Procurement
            features of Nexus Professional give architects and management more
            oversight over the artifacts which are allowed into an
            organization. Using the Procurement features, a Nexus
            administrator or Procurement manager can allow or deny specific
            artifacts by group, version, or path. You can use the procurement
            manager as a firewall between your own organization’s development
            environment and the 95,000 artifacts available on the Maven
            Central repository.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Enterprise Security</term>

          <listitem>
            <para><indexterm>
                <primary>security</primary>
              </indexterm>Nexus’ LDAP integration allows an enterprise to map
            existing LDAP groups to Nexus roles and provides Nexus
            administrators with a highly configurable interface to control
            which individuals or groups have access to a fine-grained set of
            Nexus permissions.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Staging</term>

          <listitem>
            <para><indexterm>
                <primary>staging</primary>
              </indexterm>Nexus Professional adds an important step to the
            software release workflow, adding the concept of a managed (or
            staged) release to a hosted repository. When a developer needs to
            perform a production release, Nexus Professional can isolate the
            artifacts involved in a release in a staged repository which can
            then be certified and tested. A manager or a quality assurance
            tester can then promote or discard a release. The staging feature
            allows you to specify the individuals that are allowed to promote
            a release and keeps an audit of who was responsible for testing,
            promoting, or discarding a software release.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
